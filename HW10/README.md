# ДЗ по парсингу

### Запуск
``python prog.py error_tests.txt``

### Тесты
* В ноутбуке test_generator.ipynb написаны некоторые скрипты для генерации тестов. С его помощью сгенерированы файлы, начинающиеся с generated_.
* Файлы error_tests.txt и correct_tests.txt написаны вручную.
* Тесты должны быть написаны по 1-му в строке в виде выражение, правильный ответ.

### КСГ
1. S --> Variable=Expr 
2. Expr --> Sum
3. Sum --> ProductSum'
4. Sum' --> [+|-]Sum | $\varepsilon$
5. Product --> OrProduct'
6. Product' --> [*|/]Product | $\varepsilon$
7. Or --> XorOr'
8. Or' --> "|"Or | $\varepsilon$
9. Xor --> AndmXor'
10. Xor' --> ^Xor | $\varepsilon$
11. And --> TermAnd'
12. And' --> &And | $\varepsilon$
13. Term --> InvTerm
14. Inv --> ! | $\varepsilon$
15. Term --> (Expr) | Number | Variable | Bool

* Number: \d+ (В этой библиотеке во время парсинга применяется int())
* Variable: [A-Za-z]
* Bool: True|False

1. Корректным названием переменной является большая или маленькая латинская буква.
2. Перезаписывать переменные разрешается
3. Тип используемых переменных - стандартный Python тип

### Перевод КСГ в парсер
#### Операнды
* Variable задается таким образом: ``Word(alphas, exact=1)``. alphas = ABC...Zabc...z, exact=1 - значит, что всего 1 символ.
* Number задается как ``pyparsing_common.integer`` из самого парсера. Внутри просто применяется функция int.
* Булевые операторы задаются как ключевые слова: ``TRUE = Keyword("True")``
* Над всеми этими операндами создана одна обертка (class Operand), которая их вычисляет(переводит из строки в значение).
* 7 правило нашей грамматики выглядит следующем образом: ``operand = TRUE | FALSE | integer | variable``



#### Операторы
* Все операторы задаются списком в объекте infixNotation. infixNotation реализует правила парсинга грамматики записанной в инфиксной нотации, то есть привычной нам. Приоритет операторов задается порядком элементов в этом массиве.
* Каждый оператор описывается 4-мя сущностями, а именно: (символ, количество операндов, ассоциативность, функция вызываемая при парсинге). Рассмотрим примеры: 
    * ``("!", 1, opAssoc.RIGHT, BoolNot)``:
        * Знак оператора: "!" 
        * Количество операндов: 1
        * Ассоциативность правая
        * При вычисление используется класс ``BoolNot``
        
    * ``("*", 2, opAssoc.LEFT, IntMult)``:
        * Знак оператора: "*" 
        * Количество операндов: 2
        * Ассоциативность левая
        * При вычисление используется класс ``IntMult``
        

#### Выражение для парсинга
* ``expr = variable + '=' + infixNotation(operand, operators)`` Это основное выражение для парсинга. По сути оно является первым правилом нашей грамматики. 

* Реализация остальных правил скрыта от нас в классе ``infixNotation``. От нас требуется лишь задать возможные операнды, операторы и их приоритет.

#### Вычисление выражений
* Вычисление выражений происзодит благодаря реализованны классам, методы которых вызываются при вычислении. 